<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eff6a4a99615056870e300d5f66560485573b18da299788f4b53ff0b00fb6921843425eb206b04d5936c2270a348bb45939e5c1a29f63de4619bc32b77e842651aedbd70ff36f7b336b260b4c808ac01687011cfd422aae592d4c4cdaef190343aba0a39fd94a3eb4b7761b60f093e43a4dfaaa22696df293e32b922a636d78c1b3dbf552848d0c1124ca7b1922b73060ee1f25898bcc700a0abbf80093e4593bbee8240700d7933a5419d9d8537ce35ae230eab2799db1c75faaeb59083267a5050418b4063a9c34486d27227410351d7d5ef2c54764e4603a87cb62adb8833938c3670d97e1cbb013557124905d4fd3c10d695affad9786ed9c69601333d9dfdc502c135a61adb9aae426da6b4131332c66e2c7f8a953c6519694fd3b1f3a790d79f055618e24b9b4851fa010c7e4284bdd6dfcc51cdebb4a6035dad9635ba9dfc3e4843acd598cb483b7bfb80a5f48480363533a48b539d149c9f8c99c39322c21571d0cef023d9b63a2f86dd6bc379c82cb323ce9f8add573eac98c89909c7fb9a80e33af5d16e8dde8bcfaba5d99899c56e9a4d54e80374b50f7303edf4289f176f3a80be8e65e2f97bae0eb08280f1006a83ef6c0e2376bd5e99c6f97e08329dcc9483427467726848b84ed98399599baab1da61e7a9c06e681c5b2763b47f14056d90aaa8f9dddd586e0d7c9b12a954636202659ee9f3e51c773bb7b8b15613fe1797b1bd6316925a8beae327f9e27cc7358106a9dd63de5ddd2acac1f65cfa56853de2f47f279532993b9639755dcd6d4de658d98bf949cba287917443baed0d042efe4edb38d19261503ccd95489f54f148aee3fa413df549724c34971231398b6fa240f37ff115cedd987827e8331095f5ec42da7149fdce974802cfa6aadfc8c32cca9b108ca31c8ef7f387dcf6822656220acabe3bcabbaddd6b79e41258ca9c04153d250e3711d94da1e22e23a56669746561abeddc2cb312b7d23cb8b8fb7467e945ab6a57d68d5fa6c3a1bea010ad90497822f66c5842cfab650b295725878ebc45dd6e778721c3266de80a82c4746660a3be85d9be71d2aaeb1adb9c1074bb12800ad8f26330ee51c133d73642a67a3fc0cd46545379f7f20c32361b7d301a6cddee4f6274c832e511ce3f5e0ccc21e029cad179170f0f41d69ca8d10de329c517e3c93faedadcc50d0a429b82a3cb5aae4f6b09401b875cb425fb41fc6c12b8810631f23dff3ceabe0e658b823d811deaf0c1a234a8e43bf2d25246479a2ff096789faf3ced3b4c88e23f6ea49e1380273d42292cb74e527577bb181d611e4608a47f33ccdd96ef9dfec0a3848f1e6f7ba4917e13f5cf9adde508f7a9115d99fe71c39428c981afce0840fa2a27fbea2c44beb3950d1e85a8e81e8eda6d93dc975dfc32e1ad83a016b51ad3c90aa4b104ba248248f8acf2c128683a79f171f3bb39bc1575cf60ba1a8a3c752e0dfc137521bc6d7d65ae448a49e2fbbdc9e99e09e33853c4d371a82cdd7cbab2ae17c177f22fa8f1331ea82eb518703fe3f273cdceb2627ff38cbd402ecc7c52cc280b788db76040ed88de5287a939d79d66dab95fcad11a7039bd84eb92daaab8993043fc0b9163d64aba37fce462566a8d21685fc8f40651313a2731965435e0476ace96065ab98c9ae5c81c0698a36a6534a56d822b0bac6f4c07071cd84b5d37fc038c56c2b039511c1c6ff620d58770d16da3002e96f568d536969c783fc6efa76d2b866b800da223026f6f60106557dd4e17c4a0dea602acc3de4d6ab3680242f0f89a8a31b09e630dd7b00b87754fa2d3442c2d83d5b8641d36314777f0867dedac963c736d41eac05d7408174dd0e40c7e17df5528b8c7ea209c674e45877387ce13953b794cbf4d57c10f810dc998f8c81242d8e23e3bc5cfdf538d45c68996d3cba37c91d64f38ab30f1a1195d4217b0ef1ff1e5d533d53da8a3310b4107dcf03a51a324fb8f85a8e4d5225368dd50049ea5688ce20811d04b027ab262c7ceafd83dbd3e9b26da307e5cbeb0459748c95ca7fa9228dc6acf7d0022675492b27e942e442429bc93d234283b8acc4d667d2e0ea59aa2cef70ba7aafabced94b89eaa7738925e14d638f2db2f1ab8ad7b79222e2ce6b13bcffdc5f6bd3700d55577a12d17fc6f050d335f1d4156fd4d698cb40a408f9fbf2cc25f5d1862acf42d2f82c9993a722f604ea33e9b310cc14d63cbf6247f620e643ef004fb11b70ea9c41f9300e9a250e8cf840bfba6998e2b7457445c3ec534bd0276d2b6be416069f1f002be891505e9770c27248d24c9d240c82cef12222b615a2191aa81e86251b11db899dfaee20931c477884fb58a2f746dea67654f183bd8d5ba7cb04f7f8d1d9f344f9d0c6d47e9c20b85b726f00d883ada225d1ba22cc188829c80ce01a99e9198ac7e1c33af3d902a08b8bd440e83f1d31e505d12b946568b48c5cd614f47b0f91bf6b1ef90175dbeb04857c7b5c5a722c0048cbef7682d07d9edf2f2ad01fac1520bd7dfed02e9664d7a298182bbe93a0091483ab78c85a015635dc4bcdc4b8aef5608142bccef6e50bad13c77537df20fea95989924f43da43a24740753486c0818106f0b9ae6772a21c5edca1fd85d8e836e0c4dbbcb917a78102ac44fc5b12c7249476ac0c8f6697287d6129ac3512df535826c3ee00c120834daeab9e0c6c76fe6a229d82a69d4da9427a308b2363ef1eea9f8bd8f3fd6b9de5d94571d1c20f2b59c62a2e407ab94777855afc9dcdce2263022282322cec52a160101ce085c0ca7a3658a81bbfeab7a02d55d0ac80fe55c26afce37cc8d735210c9405516f65d970354261a517393697af38f44ac0f99b1238512543e800d626f3d7c862969eded1586c378417627234c6894ccced6f84725396d25b36b0f28035584dbb6a53f0e12f00404ac329924266701444e7450d0e0b31b2ad7233a5008a0f5feaa244ec9a53d706ea61017ca4d9f681ef331fac753b272be893d4e43b3be48561ceb9333ec918affa02f798fcca12dcdfd2cd8aa8dfcb4a50d97992c41206d183f56de48370e729d3b9812c0ff26050f89502fd3044a53e3ccae292fd47abe7509dd2d8e997eeaeb43148c81ecb804327247794976d80277d6b33750471c0905ff884cb04bc4525933ee121a9e4969687007a7568a0c53e1d676b505020a7ae69ca7959a058f070f940ae125c778917e98069144684c2127d8b132537feb9b54d96578e6aedffb7ac98958c579af4f75ba12d102edcf09508f36d1dc9565da636dc1443d2380ee954cbacbf71a9fd6e3e8b0d3b4abd454efeb68b31d3cbc0cf29beced7fb18453c2536c8cbaa787c21685123eedb2053158adaea4822eb262e8c6d7d65c2df9ac73bcbac919c6d67f0296a48301a342066580229397c241dfc4e97efc029af2b018bc4d00aed56a3b13587db0a288ccc07542a3beac485f5254a1e897fa3b72e551068a1b255f88a0101238cc8ddf0608b8c53c45db325af85a16a2117c662b7ecd99f6be0f43757641ce690f37163470f3c1fff9b33ac5fdc042818d466771596a5e866ec7265cceb49bc7bf76a33c4c2d53e8e163a6800794ff80efa4033738ad1c3bd47e64dff25e4b3ba46c7b2427f37b7eb2495f019d17ad05767d7438d58cb75e0cd2eec43a858796a77c2dbfc99f2cca39fa7cccf39c71512dc6e6ec35ac98286557d474fa83eec7a76145bc01f42fb973e8f8404d0ec21732c982c3235e352b11d3b36fb5b3758635ce93b80602c55fd9576b7f59b9ba3f272fe7edd25def8fa742cb74718c389dec57c4a241108ade8243c4d0252e7cf5c4cac09c582e10a20b70676acb8916e66d6c72cd49c216ae09c263d642d5160ac19e0809109f1235c18f11e05303d22fa4b54068888b3b8226b9dcf90b972607a6cfe979fe2aee09cedb5ce1c897db35946a9e0381377c0e23cfcc1fc34cf78ca7df5533ef0f7beaf88e8311ba7456a09889928963a8ea23bdbc33328ffecc604d812c68ae88acc393823b1dfffb5c00a13bbc20b85dd05315ee682b05f2b3841f6b58143e4c732328b53729a9be0af65c6337ad3715db891966d8df9e7747a7c95f76148a2b479307e7aa36d99e3639b88a475f9a8cd049e5601121019f9695506fe3274b586c623907fac5fa8589e64b5508fa5667a3bb7591ab49256eb90dc6da29f3ca17e65dd30559e3468f7daecf6c009d00263ba2249ea90447646d7b1202eec7863465d0e6b9372d1f81349394b7b5ea406027b7be4c9a4577c94be61d171124f54242b3ebb30ad75f87386751af37653606907006e8d2023dcf33d0065b2f3ebab98c883737995d05977534dbfaf0b6b55f7841f9c5898972b2edd2c52e5658ed8a6a8492f6c61690d686ba91ebe035146152d93a8d205403ea162d367a7d6b9ee55b82c017940ebc7cf5f062ad1618decf98a48825d375d0067afa99cb6f9d0f99381bfd9b1f18c9a201c36b1dbd0d12f063e993cf0075bb0e1f1c23436fd7a25852cfd0efd26a7511bd9073e99f8820c3600f82619f467d08b7f138442a0752046974e19f3df25887db4cb3f414050d46ce94cef9ac7275386033ce179d540f9a90c833d7ec521726325585506aff88ca8c854f01f83291eb998455df58d6608a20ffcc7ae154516b67cd0c849eaf97e51f6bf175681830cf986339bfc15c916fc2d172a57b48572b0248545bf917aca1d3f766257d7ba2c646f5b29b94e496b13e75e2fdf3d401f8e08c7b9d045775e10251953401722ddfdb8e3a1c64afe3d7b177277cd15f76f20aa34c03d6c182b191b14d50028d9671abda4299eac212596e307651503eeaafaacd8b699b0ede096c6e2f62064f278997079fc6f4ca9a31008ec90d4d1fdfe15e8c1933e6be91301859a0b60581537cc1d04d7a0460589ad00ad36fe68a0573553ec1253d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"aaa7356432e3d4e263dae4a4f9b5bdfe"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
