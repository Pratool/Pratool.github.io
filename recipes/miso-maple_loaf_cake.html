<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66463e781f7cc87e1dd5d959437ba528f086e191eba654ba6425f2d16caaf4cb9c41a931ca7477773a648f78f003e9f85fa833b488927c8f9ff628975d0c249a1fd243e3461b0651431c25cf8a038e50229aca8f205c26f0994dc2404a5e46c73d27c12f2ab66e1a0f9d4a2362da3820b2b65579eef2d506b5a7106552e29ed860c5f4689abc003b8a60810c032e08b594350583de5c3e0c084fec5c4d6d8e9b28c3c930aaf767cb58213bb5161e0396eb15ab21325b5e009391f4a098c1be4f39dc2c6e7d3cf1af1248ee331a281bff9b4aa69daf605c55fd740134322d0c686d760a4a9722974e5383545d94d5bfe1572561ef60cc16edeaa542d6002c71afad936a36126b667e60f41fa9765d1e0188bb5e1b557e34b13fb5605dafa73dd13d8d698707bea71d21083df42a3e4e0a2e84af49639a93b8472fafa446a731b7d5f6c7e52cacca8cb81847537621716b8121221401788a058b4dbdcad9fc2aeeba2f96f823de992229edc20d96e53f5131a7cde099763d28dd4ac83659b38b9105388a2c9e9a94eb31781823aa11a48794f88f4ba09cb29382f8ec1f98fbcf8dfae75854f73d791bdc708b91a2f8c97fb6e924282f7bc23ae7b17f9f2b0d18b5443f5e86ef030e07d9c91b7914712553e97287ec68bb8d2d0016305dcab6708f28f5b6f0690f943be2dec075242d42cd3551e82836376375a8b453d4b93a6a12d12b4088ffcca84d4363dc2b624d371c42e9654675a28d834ae632fa1c38a9c1a148751628e24bdd0abbe52c16d166e2f8a080b763139703b05e1d973949eebf6592b55ab070ce19b9acf4e996c03f56ef01ff4ec36937b7ce56f4bfea709a0e1e43bef92b1fe719d887360aa18c4ff0cb88b10b1ce90e39741ad6b1d6f8da073b68cb28ed1b513f073f277d256a134777f82bfd23ea5fd3be366417d254f14053ea4a72690ef09537ff51f88c487657833f0e2766ad22dcd6d26a3047f5a3a0a8bca8645d178aa5cc26d349fbbf0ce9cba22ea2836fd09808c82f3ca336200758337cc60de4a4dc19ed07680feb8863e5dcc72e81bbc272caa9e83751493560e72eb6ce1d49e6fcd477e5836398ee6b25da52e4765f0d1b013338e899a847c931074b63ae3936d796e0948f546cb3580a44031f73f7e77b596300ebf102c455c84abf5bc19c8f8d1342f74431d5106ce6f7c9477a5852c1116685c79daa6b4f447298f6860677d0f755b6643c9a8c867c2835c17a745ae1481e6101ea4b8b70cafe96770ce696121c3a1f20e90629ba61589abc5b89f85b71e33935f2cf6940fc75a2dae8b8da35088a81bdc537b00156a4de4868acd564134f3fd1ce52de5737417b32475128c444fe199cf44c80d642a0b4c184a7f75a6bbc136d4df559eb2e9d7f37c420279857a0bca282c073b7027eaf9d98cff95d8477e1108b118ffe931afc0f746f9695e518760922c7366eb57a9402d0d74c7b207d82452554e449b9d3798cf0ba0e6fba7b8153799eee84fa155ad03305eb9d9a706329e723b9743a5125adccbd01b04908953aa9046e5808cf4330083d4cc312efcb93bfea883885ea74d0bb67b1113e53b92c946e5f8330c75c59f004c47c0014926af57042f60a46b926c7ee097d890cbbccc94ce067f43455cf2b1d10adf27adcaff9a31e109f1fbcb0b27247e7520e38fb54d0869dff27a5ef9f0a51694f900c56872353fbf76863c013d0de786f89cd74abd35048ed8ba62b55a51346cb9562b47a2cf5b8b74bc2f548f62369f8419b0707ec437c3fa235a9d8ce3e8018afae4b3bbcac007a0bb804d7a90dab3e9a35457999b35371dc1a4df97779d321e1f377bf089a8783e99b01c949bc721cc25a6bbeff2894af4935b66c566f545d2ce2aa4b6c9c0e0be5b8a1def8096213bb2043a7d1f4e2af21c72c175fe47844f9fdacb8a4d48e7a05a39b503a0087aa8cb16867f91435b4c1e46e43a1533c174a48fc8209e530275b9813345cc0bd0c7e28d7dce0ad1b5631f8a1cd8ec541a77976429fa9e374db533cb476b1884573cfcfc79c54535b170dec830005542fac9065cdadc70dcd4fd0f087a6f77bb6e2762b3e58d49bf7f3effdfe2ac2a30b6255006be87446f6b9117c3f38158bb19d492288138da0a388a1099cdfb69cc44438477f6b1438893ff8fad5d644cc6a407862fb72507d381f0b6f683023d5812684f04fef239714d2db0ae901480bdddadb6572538f37ea8f2d7f783e009b5468c50cd984658750eac3a588f88ab0b568c45b01fb65a155ced2dcdf82cc86ece9147c812f179658934bd4e820ba7a001cac69c91068cfa3ca450ec3417ae4469280a4317fdb4853a3ea8d48fcfb261a892ccccf7489a52d113cfad2cfa1f5b0c3a3ec16f71771617aed50dfdc6aec4c961d09ae91324a37fcd79b611a651e730c7317db0075c9abf7cb4b89f6b2238af9884a6e61d289b94c7345ba744829dde74ebd274f1d0fbbf84607deab4575331805fcf9151ead8785871dac39e98cb4071d83b47e0116772806447d806b240807a6ccd1b2e0b52b5aaf5bb6287ea82c24b3f1c8309f5976cb58824190440de12c2a24a409529c2ff61228b8511d628afea1e0bfc574aef55b29b78faa19ac681447668d689da9a169375120e62f0920e2aebe9dd60d5abecb9b1bd453934a12124ad9c0e5d727910e3ccaf19d99205c1d84017f5212020d8525e7e6297261834b94dc53c79441406786097538a3aa054c42343fbe83e2fd6fe384ca3aaff6cdf0aef5afb4e37ee31fa5d5258acd65a80b90c79aac0e12063d221ef6a398456810e15348e47d9fdb7333f2fd03bc0a3f51e4bf53e998b3053e204c832bf99cb9bd0dcaf9d3e3e748a91feb71d6aa3744b50452e421b6f5ed098f91d9b41752920801282eaab3adfb83a30e81463c00f0eee72e676de74df714b25a383b43c84fc4d9baca5ca1de54b61667cab764ae9e865c8c4789fa57bff2947ef88b4cc5fb0040ec1517f4a48a7f4de17a4abf6c8660412927fd266d3c0d5ad010708bb0585325fa3311230a0df4a3460e05d8dc0e8cee06cd942853b9276ce84af2eaea50128b104377719fa02ec7e9d86af77f2b14e2c9ea6e69d54979c23120cb4ae1b5f3143333af5a6923f13bb835184f9d50b1b8df33eccc4b5fe9f82f622f0022794e3a6c0b8f3c5402e169c98ab8ffa3de356304a47ea5d28b68350db56e5af2e14922978689288636e3ef49827a0fa8fdcef9fd070a6b728869fb4545c1546a82c1f95cd682142f4484fd25c834f805bdc450c75cfc63027a998b6071ad1cdb0ef3d1c42f2fa569c43dfd0cafb192d6bbf064b051aff62ea8d5c372272da6b61478d134b911eae30992b19d41134391a639c9c204564eda428669a6f39d291d5cdd9060aa94e527c60464875bc6aca8d75db80aaf6dc643409025c1dab15d64dc08c323f5373b4d89bd238d375e4d049329bf01712141e1097e8da09535989626b2a53d23767a972ca4f3e4a2102fef673c47104358d125a526de4f6a2248ff82824202a03283fe9cc4c4ad339cd1ef08178d5e59a14af6853a98d2505fc208ad46dbce93d49b5633ee8f8ea2285a104bee4675c4fae660f3808d560e1eaef7c9119e2ecfb3e0cc124099dbeca0e0702ab3439c79e07f4f5b8850876f2d1ed6c57295a1229d857671638addd35154c7455e5e163e29505247cfdf0f9ab6bd6f5c47e87c04554416e5e65811d4afdfec6df3ce986069140c04129bc1e6cdbe87c728d3f070e9803b1629e53a78118eaaf1d0b70edc97f0c89b341844d6e9acc9581d0c7a25116cb8d0cae1e11f01796913423eee22ee62c7e5f597ec1a02e8daa9d5ab3faa0565eba773005e31ce0ff3d08bf15b3db08bce27dc68274bf16b0b741190dfc1f2b6a1b158b17320d06ddc8624800cd7f9f94504dbb14a085d0d5daa64c9c8d0c0fe0dd74b348d867d7412aeb41670e7b641e8ebfd1198c1fb2f60b40dab521dc81094411d102db21500f5b622adc2e5c2f65af25f2f9767e094b2ee3346d4e0770d2d76298c9a1441f419ebb2ad2951f22deef20eab9d028d30e5d29f2a66a33efae0478c258039b658585a966a4646c82c6663d54b1ae6a838a8a1fbbcb77d43b9958b1eda1d928484dba5401d8038dafbde00189fc43dec7241e7fda1cf9f9ac8e0529bbd1cea0a06d35b8549dc822eb85ec2dffff714476e855ebf597815b01eca3a2616c6eec23fdf83b16f0e9fa22f4ab0934c7582b5c823933850ec1b89e136965ffa9226d348d1f395fc2e924b66d3db2db719096d1e9f5cfbbedfe4e02579b44079807c8c8eafd0ad93419927bcb76921fac90d89ee12b42f710d33091f19f03cd229450b5959984177110493891e956a636c6e9eaf1143f0c72acea207d54609d1bd337de3e0fbfe7ae2e7872405129ebccef9329579365163b3dc6d93f9c7dd53ceafd1ccbd2b370d6b22da9fdb71d3d713b68cd7c66eb0f3cc2f194d8a4e7b8c49381ae933ed24f9c590d09748c73e8f5ff8e4e17fcf8e1f2142eddcbd737d15537eb1e28de3bca3112674663d574399557808171a13fca59ed21179f206d2bcc9c53dff795fa05c0341c11f3a281f31f1a8985263fd06275be8262b2f11e6ce7c07fad7f10a4579659e61777c2933e82b1777434990d1ee63bfbfd861736f0c5e320c23d78e179fcf941d13ab06113783afd6e9c1bfe0a3891a319cf7042e3e257439d8ab544b2c9205326331bce76039aa9a21415a5db1016913eb8d5afa4125a09dd800217ca35cc8dc901c22ef597fdc38371e63d434b43f9cf45cc454a088bf8b15463c55c117735ddc1233a22a1cc7df29329ee36a6e55c8b47a04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"47ddb6647a69016945e6bc087fab5489"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
